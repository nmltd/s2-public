{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "x = [1.874065, -0.465820, 1.884720] , fx = -38.28482786994783\n"
     ]
    }
   ],
   "source": [
    "/**\n",
    " * Solve and SQP problem with only equality constraints using an active-set solver.\n",
    " *\n",
    " * example 15.1 in Andreas Antoniou, Wu-Sheng Lu\n",
    " *\n",
    " * @author Haksun Li\n",
    " */\n",
    "\n",
    "%use s2, algoquant\n",
    "import dev.nm.solver.multivariate.constrained.general.sqp.activeset.SQPActiveSetMinimizer.Solution\n",
    "import dev.nm.solver.IterativeSolution\n",
    "\n",
    "// the objective function: min f(x)\n",
    "val f: RealScalarFunction = object : RealScalarFunction {\n",
    "    override fun evaluate(x: Vector): Double {\n",
    "        val x1: Double = x.get(1)\n",
    "        val x2: Double = x.get(2)\n",
    "        val x3: Double = x.get(3)\n",
    "        var fx = -Math.pow(x1, 4.0)\n",
    "        fx -= 2.0 * Math.pow(x2, 4.0)\n",
    "        fx -= Math.pow(x3, 4.0)\n",
    "        fx -= Math.pow(x1 * x2, 2.0)\n",
    "        fx -= Math.pow(x1 * x3, 2.0)\n",
    "        return fx\n",
    "    }\n",
    "\n",
    "    override fun dimensionOfDomain(): Int {\n",
    "        return 3\n",
    "    }\n",
    "\n",
    "    override fun dimensionOfRange(): Int {\n",
    "        return 1\n",
    "    }\n",
    "}\n",
    "\n",
    "// the set of equality constraints, E1(x) = 0, E2(x) = 0\n",
    "val equal: EqualityConstraints = GeneralEqualityConstraints(\n",
    "    object : RealScalarFunction {\n",
    "        override fun evaluate(x: Vector): Double {\n",
    "            val x1: Double = x.get(1)\n",
    "            val x2: Double = x.get(2)\n",
    "            val x3: Double = x.get(3)\n",
    "            var fx = Math.pow(x1, 4.0)\n",
    "            fx += Math.pow(x2, 4.0)\n",
    "            fx += Math.pow(x3, 4.0)\n",
    "            fx -= 25.0\n",
    "            return fx\n",
    "        }\n",
    "\n",
    "        override fun dimensionOfDomain(): Int {\n",
    "            return 3\n",
    "        }\n",
    "\n",
    "        override fun dimensionOfRange(): Int {\n",
    "            return 1\n",
    "        }\n",
    "    }, // E1\n",
    "    object : RealScalarFunction {\n",
    "        override fun evaluate(x: Vector): Double {\n",
    "            val x1: Double = x.get(1)\n",
    "            val x2: Double = x.get(2)\n",
    "            val x3: Double = x.get(3)\n",
    "            var fx = 8.0 * Math.pow(x1, 2.0)\n",
    "            fx += 14.0 * Math.pow(x2, 2.0)\n",
    "            fx += 7.0 * Math.pow(x3, 2.0)\n",
    "            fx -= 56.0\n",
    "            return fx\n",
    "        }\n",
    "\n",
    "        override fun dimensionOfDomain(): Int {\n",
    "            return 3\n",
    "        }\n",
    "\n",
    "        override fun dimensionOfRange(): Int {\n",
    "            return 1\n",
    "        }\n",
    "    } // E2\n",
    ")\n",
    "\n",
    "// construct an SQP solver\n",
    "val solver = SQPActiveSetOnlyEqualityConstraint1Minimizer(\n",
    "    object : SQPActiveSetOnlyEqualityConstraint1Minimizer.VariationFactory {\n",
    "        override fun newVariation(\n",
    "            f: RealScalarFunction?,\n",
    "            equal: EqualityConstraints?\n",
    "        ): SQPASEVariation {\n",
    "            // This implementation tries to find an exact positive definite Hessian whenever possible.\n",
    "            val impl = SQPASEVariation2(\n",
    "                100.0, // Han's exact penalty function coefficient, the bigger the better\n",
    "                0.01, // the lower bound of alpha; the smaller the better but cannot be zero\n",
    "                10) // the number of points between [lower, 1] to search for alpha; the bigger the better\n",
    "            impl.set(f, equal)\n",
    "            return impl\n",
    "        }\n",
    "    },\n",
    "    1e-10, // epison\n",
    "    200 // max number of iterations\n",
    ")\n",
    "\n",
    "// solve the SQP problem\n",
    "val minimizer: IterativeSolution<Vector> = solver.solve(f, equal)\n",
    "\n",
    "// the solution\n",
    "val x: Vector = minimizer.search(\n",
    "    DenseVector(100.6, 37.3, -23.95), // the initial guess\n",
    "    DenseVector(-100.0, -1.0) // the initial Lagrange multipliers (lambda)\n",
    ")\n",
    "val fx: Double = f.evaluate(x)\n",
    "println(\"x = $x, fx = $fx\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Kotlin",
   "language": "kotlin",
   "name": "kotlin"
  },
  "language_info": {
   "codemirror_mode": "text/x-kotlin",
   "file_extension": ".kt",
   "mimetype": "text/x-kotlin",
   "name": "kotlin",
   "nbconvert_exporter": "",
   "pygments_lexer": "kotlin",
   "version": "1.5.30-dev-598"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
